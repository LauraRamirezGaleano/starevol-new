
      PROGRAM EVOLSTAT

!|-----------------------------------------------------------------|
!| Purpose:                                                        | 
!|    This program analyzes the output files generated by the      |
!|    starevol code, in order to study the evolution of S-AGB      |
!|    stars from the core H-burning to the TP-S-AGB phase.         |
!|                                                                 |
!|                                                                 |
!| Record of revision:                                             |
!|    Date    Programmer           Description of change           |
!|  ========  ==========    =====================================  |
!|  12/06/05  L. Siess      - Original code in F77                 |
!|  22/06/05  M.L. Pumo     - Comments are added                   |
!|                          - Changes (F77-->F90) are done         |
!|                          - Mistake in 'iendH' is corrected      |
!|                          - iH(He)core and iDUP1 are initialized |
!|                          - Action 'read' is added in reading    |
!|                            the input data files                 |
!|                          - Variables not used are eliminated    |
!|                          - Reading of input files not used      |
!|                            is eliminated                        |
!|                          - lCmax is added                       |
!|                          - Format 3631 is changed               |
!|                          - Mistake in boundaries of convective  |
!|                            zones during C-burning is corrected  |
!|                            (other checks are necessary!!!)      |
!| 24/06/05  M.L. Pumo      - 'etamC' is added                     |
!|                          - Calculation of the end of C-burning  |
!|                            phase is corrected                   |
!|                          - Comments are added                   |
!|                          - Action 'write' is added in writing   |
!|                            the output data files                |
!|                          - The output file .sm is created       | 
!|                          - Variables (used to have the mass and |
!|                            the metallicity of initial model)    |
!|                            are added                            |
!|                          - Mistake in 'mNeOcore' is corrected   |
!|30/06/05   M.L. Pumo      - Mistake in caculations of iCstart    |
!|                            and iCend is corrected               |
!|                          - The nmod value is changed according  |
!|                            to the "real" dimensions of the      |
!|                            input files (maximum number of lines |
!|                            is 200110 for the stellar model with |
!|                            M=9.0M_sun and Z=0.0001)             |
!|01/07/05   M.L. Pumo      - Mistake in the merging of near       |
!|                            convective zones is corrected        |
!|                          - Mistake in 'lCmax' is correct        |
!|                          - The merging and removing of the      |
!|                            convective zone are separated and    |
!|                            are also corrected                   |
!|07/07/05  M.L. Pumo       - Format 3641 is changed               |
!|                          - File '.xspc' is added                |
!|12/07/05  M.L. Pumo       - Variable used to calculate the value |
!|                            of Y (Y: X+Y+Z=1) is added           |
*                                                                      *
* $LastChangedDate:: 2014-02-04 11:25:49 +0100 (Tue, 04 Feb 2014)    $ *
* $Author:: decress1                                                 $ *
* $Rev:: 5                                                           $ *
*                                                                      *
!|-----------------------------------------------------------------|

      
      
      implicit none



      !----------------------------------------------------------
      ! Declare the variables and parameters used in this program 
      !----------------------------------------------------------


      integer, parameter:: nmod=1000000,nspi=44,npul=1000,
     &     ncarbon=100
           !nmod    --> maximum number of models in the input files
           !nspi    --> number of chemical species
           !npul    --> maximum number of pulses
           !ncarbon --> maximum number of convective zone where the
           !            C-burning occurs (during the C-burning phase)  


      character (len=1):: cdum

      character (len=100):: seqname
           !seqname --> name of input files without extension,
           !            so if the names of input files are 
           !            m10_z0.001_g270.c*, m10_z0.001_g270.v*,
           !            ...etc., then seqname is m10_z0.001_g270
      character (len=3):: nca
           !nca --> total number of convective zone in a given 
           !        model (it is a character because the format 
           !        in the input file is 'nc', where n is the 
           !        number of convective zones)
      character (len=10):: xcfchar
           !xcfchar --> 10-character variable containg the string with
           !            the C mass fraction inside the convective flame
           
       character (len=5), dimension(nspi):: chemi = ( /
     & 'neutr','proto','deutr','He3  ','alpha','Li6  ','Li7  ','Be7  ',
     & 'Be9  ','B10  ','B11  ','C12  ','C13  ','C14  ','N14  ','N15  ',
     & 'O15  ','O16  ','O17  ','O18  ','F19  ','Ne20 ',
     & 'Ne21 ','Ne 22','Na23 ','Mg24 ','Mg25 ','Mg26 ','Al26m','Al26g',
     & 'Al27 ','Si28 ','Si29 ','Si30 ','P31  ','S32  ','S33  ','S34  ',
     & 'S25  ','Cl35 ','S36  ','Cl36 ','Cl37 ','heavy' /)
           !labels of the chemical species


      logical icz(nmod),itp(nmod),errflame
           !itp --> used to define the presence of flames during 
           !        the C-burning phase
      logical AGBphase,SAGBphase,below,twoflames,debug,simultaneous
           !(S)AGBphase --> used to see if there is a AGB (SAGB) phase
           !below       --> used to see if a 2nd flame is below a 1st one
           !twoflames   --> used to see if there are two flames
           !debug       --> used to debug during convective C-burning if 
           !                it is set to 'true' 

      integer :: cRGB = 0
           !used to evaluate the right finish of H and He core burning
           !when there is a jump in the nphase
      integer :: ih1=2,ih2=3,ihe3=4,ihe4=5,ili7=7,ic12=12,ic13=13,
     &     in14=15,in15=16,io15=17,io16=18,io17=19,io18=20,ine20=22,
     &     ine21=23,ine22=24,ina23=25,img24=26,img25=27,img26=28
           !integers corresponding to the position of important 
           !chemical species in the array 'chemi'
      integer no,mcar,idum,lenc,nseq1,nseq2,ipw,dnmod,ndel,jsh1,jsh2
           !no   --> used to read the number of a given model
           !mcar --> used to read the number of the sequence 
           !         of a given model
           !idum --> used to read dummy integer in the input files
           !ndel --> minimum model number to have a secondary flame
           !
           !
           !
      integer iendH,istartH,istartHe,iendHe,istartRGB,iendRGB,istartC,
     &     iendC,istartAGB,iendAGB,istartCcore,iendCcore,istartflame,
     &     iCcoremax,nflame,nflame1,nflame2,nflame_cur,iHecore,iHcore,
     &     iHetmp,iLCcoremax
           !iend* (istart*)  --> line of the input file corresponding
           !                     to the end (start) of the *-burning
           !                     (* means a given phase:H, He, AGB...)
           !istart(end)Ccore --> line of the input file corresponding to
           !                     the start (end) of the core C-burning      
           !istartflame   --> line of the input file corresponding to the
           !                  start of the flame
           !iCcoremax     --> line of the input file corresponding to the
           !                  model for which the convective core extent
           !                  is maximum during the core C-burning 
           !iLCcoremax    --> line of the input file corresponding to the
           !                  model for which the carbon luminosity is
           !                  maximum during the convective core C-burning 
           !nflame        --> number of flame
           !nflame1       --> number of the 1st flame in a given model     
           !nflame2       --> number of the (eventual) 2nd flame 
           !nflame_cur    --> number of total flames in a given  model       
           !iHcore (iHecore) --> line of the input file corresponding to the 
           !                     model for which the convective core 
           !                     exestention is maximum during the core 
           !                     H-burning (He-burning)    
      integer nmods,nmodf,npuls,iSAGB,iAGB,iHflash,iDUP1,iDUP2
           !nmods --> real number of models, corresponding to 
           !          the lines read in the input files 
           !
           !
           !iDUP? --> line of the model for which the convective envelope
           !          exestention is maximum during the ? (1st or 2nd) DUP
      integer iCOcore,iNeOcore
      integer i,i1,i2,m,m1,m2,jj,j,k,kk,err,pp
           !jj             --> number of the flame (when there are two flames)
           !                   which ends before
           !i m j kk tt pp --> integers used as the loop counters
           !err            --> status of the open operation for the file .hr
      integer model(nmod),nphase(nmod),nseq(nmod),modseq(nmod),ncz(nmod)
           !model   --> number of a given model
           !nphase  --> phase of a given model
           !nseq    --> number of the sequence corresponding 
           !            to a given model
           !modeseq --> number of the model corresponding
           !            to a new given sequence
           !ncz     --> number of convective zones in a given model
      integer ibegtp,imod,mbeg(npul),mtop(npul),mend(npul),
     &     mdup(npul),mdupcn(npul),mbot(npul),dupH(npul)
      integer mHa(npul),modbeg(npul),modtop(npul),modend(npul),
     &     moddup(npul)
      integer iCstart(ncarbon),iCend(ncarbon)
           !iCstart(end) --> line of the input file corresponding to the 
           !                 model for which a given convective C-burning 
           !                 starts (ends)  
      integer modelf(nmod)
           !modelf   --> number of a given model in the .flame file
      integer iores

      double precision mt1,mt2,mb1,mb2,xmtop
           !mt(b)1(2) --> mass coordinate of the top (botton) of the
           !              first (second) flame
           !xmtop     --> used to remove convective zones above the 
           !              He shell burning or, if the He shell burning 
           !              is not present, to remove convective zones 
           !              above the convective envelope

      double precision Yini,zini
           !Yini --> value of Y of the initial model (X+Y+Z=1)
   
      double precision leff(nmod),reff(nmod),teff(nmod),
     &     mloss(nmod),mtot(nmod),time(nmod),tcpu(nmod),ttot
c      double precision dtn(nmod),roeff(nmod),geff(nmod),rtot(nmod)
           !leff  --> surface luminosity of a given model
           !reff  --> photospheric radius of a given model
           !rtot  --> total radius of a given model
           !teff  --> effective temperature of a given model
           !roeff --> photospheric density of a given model
           !geff  --> photospheric gravity of a given model
           !mloss --> mass loss rate of a given model
           !mtot  --> total stellar mass of a given model
           !dtn   --> time step of a given model
           !time  --> age (in year) of a given model
           !tcpu  --> CPU-time used to converge (in sec) of a given model
           !ttot  --> total CPU-time (in hour)
           !N.B. all the above variables (except that ttot) are 
           !     in the file *.hr
      double precision tc(nmod),tmax(nmod)
c      double precision rhomax(nmod),etac(nmod),tmax_mr(nmod),rhoc(nmod)
           !tc      --> central temperature
           !tmax    --> maximum temperature
           !tmax_mr --> mass coordinate of tmax
           !rhoc    --> central density
           !rhomax  --> density at the location of tmax
           !etac    --> central degeneracy parameter
           !N.B. all the above variables are in the file *.v1
      double precision lh(nmod),lhe(nmod),lc(nmod),lne(nmod),
     &     lgrav(nmod)
c      double precision lnucl(nmod)
           !lh  --> luminosity associated with H-burning 
           !lhe --> luminosity associated with He-burning 
           !lc  --> luminosity associated with C-burning 
           !lne --> luminosity associated with plasma neutrino loss
           !lnucl --> nuclear luminosity
           !lgrav --> gravitational luminosity
           !N.B. all the above variables are in the file *.v2
      double precision xmb(nmod),xrb(nmod),xtb(nmod),xrob(nmod),
     &     xmt(nmod),xtt(nmod),xrot(nmod),xmenvb(nmod),xtenvb(nmod)
c      double precision xroenvb(nmod),xrenvb(nmod),xrt(nmod)
           !xmb (xmt)   --> mass coordinate at the base (top) of the 1st
           !                convective zone (CZ)
           !xrb (xrt)   --> radius at the base (top) of the 1sy conv. zone
           !xtb (xtt)   --> temperature at the base (top) of the 1st CZ
           !xrob (xrot) --> density at the base (top) of the first CZ
           !xmenvb  --> mass coordinate at the base of the conv. envelope
           !xrenvb  --> radius at the base of the conv. envelope
           !xtenvb  --> temperature at the base of the conv. envelope
           !xroenvb --> density at the base of the conv. envelope
           !N.B. all the above variables are in the file *.v3       
      double precision xmb2(nmod),xmt2(nmod),xmb3(nmod),xmt3(nmod),
     &     xmb4(nmod),xmt4(nmod),xmb5(nmod),xmt5(nmod),xmb6(nmod),
     &     xmt6(nmod)
           !xmb* (xmt*) --> mass coordinate at the base (top) of the *
           !                convective zone of a given model (* means
           !                the number of given convective zone between
           !                the first one and the envelope: 2nd, 3rd,...
           !                ..., 6th convective zone)
           !N.B. all the above variables are in the file *.v4         
      double precision xmHeb(nmod),xmHem(nmod),xmHet(nmod),xmHt(nmod),
     &     xrHeb(nmod),xrHet(nmod),xmHb(nmod),xmHm(nmod),xetaHem(nmod)
c      double precision xtHb(nmod),xtHt(nmod),xrHb(nmod),xroHb(nmod),
c     &     xrHt(nmod),xroHt(nmod)
c      double precision xroHeb(nmod),xroHet(nmod),xtHeb(nmod),xtHet(nmod)
           !xmH(He)b(t)  --> mass coordinate at the base (top) of the 
           !                 H (He) burning region of a given model
           !xtH(He)b(t)  --> temperature at the base (top) of the
           !                 H (He) burning region of a given model
           !xmH(He)m     --> mass coordinate of a given model where 
           !                 nuclear energy production during H (He)
           !                 burning is maximum 
           !xrH(He)b(t)  --> radius at the base (top) of the H (He)
           !                 burning region of a given model
           !xroH(He)b(t) --> density at the base (top) of the H (He)
           !                 burning region of a given model
           !N.B. all the above variables are in the file *.v5 (*.v6)
           !     for the H (He) burning region  
      double precision xmCb(nmod),xmCt(nmod),xmCm(nmod),etamC(nmod)
c      double precision xrCt(nmod),xtCt(nmod),xroCt(nmod),xrCb(nmod),
c     &     xtCb(nmod),xroCb(nmod)
           !xmCb(t)  --> mass coordinate at the base (top) of the 
           !             C-burning region of a given model
           !xrCb(t)  --> radius at the base (top) of the C-burning
           !             region of a given model
           !xtCb(t)  --> temperature at the base (top) of the
           !             C-burning region of a given model
           !xroCb(t) --> density at the base (top) of the H (He)
           !             burning region of a given model
           !xmCm     --> mass coordinate of a given model where 
           !             nuclear energy production is maximum
           !etamC    --> degeneracy at mass coordinate where 
           !             nuclear energy production is maximum
           !N.B. all the above variables are in the file *.v7
      double precision xsps(nmod,nspi),xspc(nmod,nspi)
           !xsps (xspc) --> surface (central) abundances mass fractions
           !                of the chemical species of a given model
           !N.B. all the above variables are in the file *.s? (*.c?)
      double precision :: mCigni(ncarbon),mCmin(ncarbon),mCmax(ncarbon),
     &     lCmax(ncarbon)=1.d-30
           !mCigni     --> mass coordinate where the convective C-burning
           !               ignites 
           !mCmin(max) --> minimum (maximum) mass coordinate of the
           !               convective C-burning zone
           !lCmax      --> maximum luminosity during a cnvective C-burning 
      integer ilCmax(ncarbon)
           !ilCmax     --> model number of the maximum luminosity during a 
           !               convective C-burning 
      double precision lhemax(npul),mtpul(npul),mbpul(npul),
     &     mHtn,dtp,lhmax(npul),eta_He(npul),pulse_mHeBS(npul),
     &     pulse_rHeBS(npul),rHeBS(npul)
           !pulse_mHeBS --> mass of the HeBS just before pulse ignition
           !pulse_rHeBS --> radial extent of the HeBS before pulse
           !rHeBS --> radius at the base of HeBS before pulse
           !eta_He --> eta at max enucl in HeBS just before pulse ignition
      double precision tbeg(npul),dtpul(npul),dtintpul(npul),
     &     dup_Mb(npul),dup_dm(npul),dmHpul(npul),lambda(npul),
     &     mtotbeg(npul),lbeg(npul),rbeg(npul),dup_Tb(npul),
     &     mlbeg(npul),tbmax(npul),ttmax(npul),robmax(npul),
     &     rotmax(npul),Mcore_pul(npul),dmpulmax(npul),foverlap(npul),
     &     fdilu(npul)
      double precision dtH,mHcore
           !dtH       --> duration of core H-burning phase
           !mHcore    --> maximum extension of convective core during
           !              the core H-burning phase
           !mtotH     --> total stellar mass at the end of the 
           !              core H-burning    
      double precision teffRGB,leffRGB,mtotRGB,mDUP1
           !mtotRGB     --> total stellar mass at the end of the RGB
           !l(t)effRGB  --> surface luminosity (effective temperature)
           !                at the end of the RGB
           !mDUP1       --> maximum mass coordinate (from surface) of the
           !                base of convective envelope during the first DUP   
      double precision dtHe,mHecore,mDUP2,xmHeC
           !dtHe       --> duration of core He-burning phase
           !mHecore    --> maximum extension of convective core during
           !               the core He-burning phase
           !l(t)effHe  --> surface luminosity (effective temperature)
           !               at the end of the core He-burning
           !mtotHe     --> total stellar mass at the end of the 
           !               core He-burning
           !mDUP2      --> maximum mass coordinate (from surface) of the
           !               base of convective envelope during the second DUP 
      double precision dtC,mCcore_conv,TburnC,
     &     TigniC,lTburnC,dtCcore_conv,mNeOcore,mCOcore,LCcoremax
           !dtC       --> duration of C-burning phase
           !dtCcore_conv   --> duration of core C-burning phase
           !mCcore_conv    --> maximum extension of convective core during
           !              the central C-burning phase
           !l(t)effC  --> surface luminosity (effective temperature)
           !              at the end of the C-burning phase
           !mtotC     --> total stellar mass at the end of the 
           !              C-burning phase          
           !(l)TburnC --> (logarithm of the) temperature at which
           !              the C-burning ignites
           !mNeOcore  --> max extension of C burning zone
      double precision t0,dt0,dum,xmenv1,xmenv2,yo0,yo1,yo2,yo3,yc0,yc1,
     &     yc2,yc3
           !dum           --> used to read dummy double precision in the 
           !                  input files
           !yo(c)0(1-2-3) --> total (sum over all the isotopes, so for the
           !                  O is O15+O16+O17+O18 and for the C is C12+C13)
           !                  molar fraction of Oxigen (Carbon) at the 
           !                  begining of H-burning (after the 1stDUP - after
           !                  the 2ndDUP - at the end)                   
      double precision xcflame(nmod)
c      double precision xc,xcf1,xcf2
           !xcflame       --> |C mass fraction inside the convective flame 
      double precision Mwind,Menv,dM,eject(nspi),ejectEC(nspi),
     &     yield(nspi),yieldEC(nspi)
           !Mwind     --> ejected mass in wind
           !Menv      --> mass of conv. env. (last model)
           !dM        --> mass loss between two models
           !eject(EC) --> ejected matter for the selected isotopes
           !              (with conv. env.included)
           !yiled(EC) --> yield for the selected isotopes 
           !              (with conv. env.included) 
      double precision mHBS,mHeBS,mCBS,mHBS_Ms,mHBS_He,
     &     mHBS_CB,mHeBS_He,mHeBS_CB,mCBS_CB,mHBS_DUP1,
     &     mHBS_DUP2,mHeBS_DUP2,mCBS_DUP2,dMcore,dMcore_eff
           ! mHcore     : max extent of H conv core
           ! mHBSm      : Hburn_Mm(iendH)
           ! mHBSt      : Hburn_Mt(iendH)
           ! MHB        : mass = M(iendH)
           ! mHBS_Ms    : max(Hburn_Mm,min(env_Mb)) up to iendH
           ! mHecore    : max extent of He conv core
           ! mHeBSm     : Heburn_Mm(iendHe)
           ! mHeBSt     : Heburn_Mt(iendHe)
           ! mHeBS_He   : max(Heburn_Mm,min(env_Mb)) up to iendHe
           ! mHBS_He    : max(Hburn_Mm,min(env_Mb)) up to iendHe
           ! MHe        : mass = M(iendHe)
           ! mNeOcore   : max(xmCt) between istartC and iendC
           ! mCBS_CB    : max(Cburn_Mm) up to iendC
           ! mCBSm      : Cburn_Mm(iendC)
           ! mHeBS_CB   : max(Heburn_Mm,min(env_Mb)) up to iendC
           ! mHeBSm_CB  : Heburn_Mm(iendC)
           ! mHBS_CB    : max(Hburn_Mm,min(env_Mb)) up to iendC
           ! mHBSm_CB   : Hburn_Mm(iendC)
           ! MC         : mass = M(iendC)
      integer iHBS,iHBS_MS,iHBS_DUP1,iHBS_DUP2,iHBS_CB,iHeBS,iHBS_He,
     &     iHeBS_He,iHeBS_DUP2,iHeBS_CB,iCBS,iCBS_DUP2,iCBS_CB

      debug = .false.
      jsh1 = 4540
      jsh2 = 4560

      !------------------------------------------------------------------
      ! Prompt the user for the name of data files (evolutionary files) 
      !------------------------------------------------------------------

      write (*,*) 'filename ? '
      read (*,'(a100)') seqname
      
      
      !-------------------------------------------
      ! Open the data files (evolutionary files) 
      !-------------------------------------------

      err = 0
      open (unit = 10, file = seqname(1:lenc(seqname)) //
     &      '.hr',status='old',action='read',iostat=err)
      if (err .ne. 0) then
         write(*,'("problem opening file : ",A,".hr, ERR = ",i2)')
     &        seqname(1:lenc(seqname)),err
         stop
      endif
      open (unit = 11, file = 
     &     seqname(1:lenc(seqname)) // '.v1',status='old',action='read')
      open (unit = 12, file = 
     &     seqname(1:lenc(seqname)) // '.v2',status='old',action='read')
      open (unit = 13, file = 
     &     seqname(1:lenc(seqname)) // '.v3',status='old',action='read')
      open (unit = 14, file = 
     &     seqname(1:lenc(seqname)) // '.v4',status='old',action='read')
      open (unit = 15, file = 
     &     seqname(1:lenc(seqname)) // '.v5',status='old',action='read')
      open (unit = 16, file = 
     &     seqname(1:lenc(seqname)) // '.v6',status='old',action='read')
      open (unit = 17, file = 
     &     seqname(1:lenc(seqname)) // '.v7',status='old',action='read')
      open (unit = 21, file = 
     &     seqname(1:lenc(seqname)) // '.s1',status='old',action='read')
      open (unit = 22, file = 
     &     seqname(1:lenc(seqname)) // '.s2',status='old',action='read')
      open (unit = 23, file = 
     &     seqname(1:lenc(seqname)) // '.s3',status='old',action='read')
      open (unit = 24, file = 
     &     seqname(1:lenc(seqname)) // '.s4',status='old',action='read')
      open (unit = 25, file = 
     &     seqname(1:lenc(seqname)) // '.c1',status='old',action='read')
      open (unit = 26, file = 
     &     seqname(1:lenc(seqname)) // '.c2',status='old',action='read')
      open (unit = 27, file = 
     &     seqname(1:lenc(seqname)) // '.c3',status='old',action='read')
      open (unit = 28, file = 
     &     seqname(1:lenc(seqname)) // '.c4',status='old',action='read')
      errflame = .false.
      open (unit = 29, file =  seqname(1:lenc(seqname)) //
     &     '.flame',status='old',action='read',iostat=err)
      if (err .ne. 0) then
         write(*,*) 'WARNING file : ',seqname(1:lenc(seqname))// 
     &        '.flame is not present'
         err = -10
         errflame = .true.
      endif

      !---------------------------------------------
      ! Reading of the required evolutionary files 
      !---------------------------------------------

      ! skip the first seven lines of the evolutionary files
      read (10,990)
      read (11,990)
      read (12,990)
      read (13,990)
      read (14,990)
      read (15,990)
      read (16,990)
      read (17,990)
      read (21,990)
      read (22,990)
      read (23,990)
      read (24,990)
      read (25,990)
      read (26,990)
      read (27,990)
      read (28,990)



      ! read data from the input file ".hr"
      m = 0
      iores = 0
      do while (iores.eq.0)
c         read (10,*,iostat=iores) model(m),nphase(m),leff(m),reff(m),
c     &        rtot(m),teff(m),roeff(m),geff(m),mloss(m),mtot(m),dtn(m),
c     &        time(m),idum,idum,idum,tcpu(m)
         m = m+1
         read (10,*,iostat=iores) model(m),nphase(m),leff(m),reff(m),
     &        dum,teff(m),dum,dum,mloss(m),mtot(m),dum,time(m),idum,
     &        idum,idum,tcpu(m)
      enddo

      !real number of model is m-1 (-1 is necessary because 
      !when the EOF is encountered m is already updated)
 999  nmods = m-1

      if (nmods.gt.nmod) then
         write (*,111) nmod,nmods
 111     format ("file too long : dimension parameter nmod = ",i6,
     &        "< number of lines =",i6)
         stop
      endif

      cRGB = 0
      ttot = 0.d0
      rewind (10)
      read (10,990)
      do m = 1,nmods
         ttot = ttot+tcpu(m)
         read (10,1003,err=22) no,mcar
c         if (m.eq.1.and.mcar.eq.0) then
c            print *,no,mcar
c            stop '1st sequence number not found'
c         endif
         if (mcar.ne.0) then
            nseq(m) = mcar
            modseq(mcar) = m
         else
            nseq(m) = nseq(m-1)
         endif
         

         !Calculate cRGB
         if (m.lt.nmods.and.nphase(m+1).gt.nphase(m)+1) then
            if (nphase(m).eq.2) cRGB = 1
         endif

      enddo
      !total CPU-time is in hour, while tcpu(m) is in sec
      ttot = ttot/3600.d0
      goto 23

 22   print *,'error at model ',no,' in reading ', 
     &     seqname(1:lenc(seqname)) // '.hr'
      print *,no,mcar
      stop

 23   print *,'Number of lines: ',nmods,', Input files: ',trim(seqname),
     &     ' --> Output file: ',trim(seqname),'.tpagb[i]'


      !read the other input files     
      do m = 1,nmods
c         read (11,*) idum,tc(m),tmax(m),tmax_mr(m),rhoc(m),rhomax(m),
c     &        dum,dum,etac(m)
         read (11,*) idum,tc(m),tmax(m)
c         read (12,*) idum,lh(m),lhe(m),lc(m),lne(m),dum,dum,dum,lnucl(m)
c     &        ,lgrav(m)
         read (12,*) idum,lh(m),lhe(m),lc(m),lne(m),dum,dum,dum,dum,
     &        lgrav(m)
c         read (13,*) idum,xmb(m),xrb(m),xtb(m),xrob(m),xmt(m),xrt(m),
c     &        xtt(m),xrot(m),xmenvb(m),xrenvb(m),xtenvb(m),xroenvb(m)
         read (13,*) idum,xmb(m),xrb(m),xtb(m),xrob(m),xmt(m),dum,
     &        xtt(m),xrot(m),xmenvb(m),dum,xtenvb(m)
         read (14,*) idum,xmb2(m),xmt2(m),xmb3(m),xmt3(m),xmb4(m),
     &        xmt4(m),xmb5(m),xmt5(m),xmb6(m),xmt6(m),nca
c 66      format (9x,10(1x,0pf10.7),2x,a3)

         !to translate the number of convective zones in a integer
         err = 0
         if (lenc(nca).eq.3) then
            read(nca(1:2),'(i2)',iostat=err) ncz(m)
         else
            read(nca(1:1),'(i1)',iostat=err) ncz(m)
         endif
         if (err .ne. 0) then
            print *,'error in reading number of convective zones in v4',
     &           ' model #',idum,' ncz = ',nca
            stop
         endif

c         read (15,*) idum,xmHb(m),xrHb(m),xtHb(m),xroHb(m),xmHt(m),
c     &        xrHt(m),xtHt(m),xroHt(m),xmHm(m)
         read (15,*) idum,xmHb(m),dum,dum,dum,xmHt(m),dum,dum,dum,
     &        xmHm(m)
c         read (16,*) idum,xmHeb(m),xrHeb(m),xtHeb(m),xroHeb(m),xmHet(m),
c     &        xrHet(m),xtHet(m),xroHet(m),xmHem(m),dum,dum,xetaHem(m)
         read (16,*) idum,xmHeb(m),xrHeb(m),dum,dum,xmHet(m),
     &        xrHet(m),dum,dum,xmHem(m),dum,dum,xetaHem(m)
c         read (17,*) idum,xmCb(m),xrCb(m),xtCb(m),xroCb(m),xmCt(m),
c     &        xrCt(m),xtCt(m),xroCt(m),xmCm(m),dum,dum,etamC(m)
         read (17,*) idum,xmCb(m),dum,dum,dum,xmCt(m),
     &        dum,dum,dum,xmCm(m),dum,dum,etamC(m)
         read (21,*) idum,(xsps(m,j),j = 1,11)
         read (22,*) idum,(xsps(m,j),j = 12,22)
         read (23,*) idum,(xsps(m,j),j = 23,33)
         read (24,*) idum,(xsps(m,j),j = 34,44)
         read (25,*) idum,(xspc(m,j),j = 1,11)
         read (26,*) idum,(xspc(m,j),j = 12,22)
         read (27,*) idum,(xspc(m,j),j = 23,33)
         read (28,*) idum,(xspc(m,j),j = 34,44)
      enddo

      nmodf = 0
      if (.not.errflame) then
         k = 0
         do 997 m = 1,nmod
            read (29,'(a1)',end = 998) cdum
            if (cdum.eq.'#') then
               goto 997
            else
               k = k+1
               backspace(29)
               read (29,*,end = 998) modelf(k),dum,dum,idum,dum,dum,dum,
     &              idum,idum,idum,idum,dum,dum,dum,dum,dum,dum,dum,dum,
     &              dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,idum,
     &           idum,xcfchar
              
               !check if the format of xcfchar is compatible with
               !a double precision. If not xcflame is set up to the
               !previous (k-1) value
               if ((xcfchar(1:3).eq.'Inf') .or. (xcfchar(2:2).ne.'.')
     &             .or.xcfchar(7:7).ne.'D'.or.xcfchar(7:7).eq.'*') then
c                 write(*,*) 'bad format at line:', k,xcfchar
                 xcflame(k)=xcflame(k-1)
               else
                 read(xcfchar(1:10),'(ES10.4)') xcflame(k)
               endif
              
            endif
 997     continue

 998     nmodf = k
      endif


      Yini=xsps(1,ihe3)+xsps(1,ihe4)


      !----------------------------------
      ! Core H burning characteristics
      !----------------------------------
      
      !initialize the variables mHcore, iHcore, istartH and iendH
      mHcore = 0.d0
      iHcore = 1
      istartH = 1
      iendH = 1

      !calculate mHcore, iHcore,istartH and iendH
      if (nphase(istartH).gt.2) goto 10
      do m = 1,nmods
         if (nphase(m).eq.1) istartH = m+1
         if (xspc(m,ih1).lt.1.d-5 .and. nphase(m).le.3+cRGB) then
            iendH = m
            goto 10
         endif
c..  compute maximum size of H-burning convective core
         if (xmb(m).eq.0.d0.and.xmt(m).gt.mHcore) then
            mHcore = xmt(m)
            iHcore = m
         endif
      enddo

      !calculate the duration of the core H-burning phase and
      !calculate the effective temperature, the surface luminosity
      !and the total stellar mass at the end of the core H-burning   
 10   dtH = time(iendH)-time(istartH)



      !-----------------------------
      ! RGB phase characteristics
      !-----------------------------

      !initialize the variables mDUP1, iDUP1, istartRGB and iendRGB 
      mDUP1 = mtot(iendH)
      iDUP1 = iendH
      istartRGB = iendH
      iendRGB = iendH

      !calculate mDUP1, iDUP1, istartRGB and iendRGB      
      if (nphase(istartRGB).gt.3) goto 20
      do m = iendH,nmods
         if (mDUP1.gt.xmenvb(m).and.xmenvb(m).gt.0.d0) then
            mDUP1 = xmenvb(m)
            iDUP1 = m
         endif
         if (nphase(m).gt.3.and.iendRGB.eq.iendH) iendRGB = m
         if (nphase(m).gt.4) then
            goto 20
         endif
      enddo
   
      !calculate the duration of the RGB phase and calculate
      !the effective temperature, the surface luminosity
      !and the total stellar mass at the end of the RGB        
 20   teffRGB = teff(iendRGB)
      leffRGB = leff(iendRGB)
      mtotRGB = mtot(iendRGB)


  
      !-----------------------------------
      ! Core He-burning characteristics
      !-----------------------------------

      !initialize the variables mHecore, iHecore, istartHe and iendHe
      mHecore = 0.d0
      mCOcore = 0.d0
      iHecore = iendRGB
      iCOcore = iendRGB
      istartHe = iendRGB
      iendHe = iendRGB
      iHetmp = iendRGB

      !calculate mHecore, iHecore, istartHe and iendHe
      if (nphase(istartHe).gt.4) goto 30
      do m = iendRGB,nmods
c..  temporary variable
         if (xspc(m,ihe4).lt.0.1d0.and.nphase(m).eq.4.and.iHetmp.eq.
     &        iendRGB) iHetmp = m 
c..
         if (xspc(m,ihe4).lt.1.d-5.and.nphase(m).le.5) then
            iendHe = m
            goto 30
         endif
c..  compute maximum size of He-burning convective core
         if (xmb(m).eq.0.d0.and.xmt(m).gt.mHecore) then
            mHecore = xmt(m)
            iHecore = m
         endif
         if (mCOcore.le.xmHet(m)) then
            mCOcore = xmHet(m)
            iCOcore = m
         endif
      enddo

      !calculate the duration of the core He-burning phase and
      !calculate the effective temperature, the surface luminosity
      !and the total stellar mass at the end of the core He-burning   
 30   dtHe = time(iendHe)-time(istartHe)

      !----------------------------
      ! 2DUP and C burning phase
      !----------------------------

      !initialize some variables (TburnC,lTburnC,
      !iDUP2,mDUP2,istartAGB,iendAGB,istartC,iendC)
      TburnC = 5.5d8
      TigniC = 6.d8
      lTburnC = log10(TburnC)
      iDUP2 = iendHe
      mDUP2 = mtot(iDUP2)
      istartAGB = iendHe
      iendAGB = nmods
      istartC = nmods
      iendC = nmods

      !calculate mDUP2, iDUP2, istartC and iendC
      if (nphase(iDUP2).gt.6.or.model(iDUP2).gt.30000) goto 40
      do m = iendHe,nmods
c         if (.not.(xmenvb(m).eq.0.d0.and.xtb(m).lt.7.d0).and.
         if (xmenvb(m).gt.0.d0.and.
     &         mDUP2.gt.xmenvb(m)) then
            mDUP2 = xmenvb(m)
            iDUP2 = m
         endif
         if (istartC.eq.nmods.and.tmax(m).gt.TigniC) istartC = m
         
         if (mCOcore.le.xmHet(m).and.istartC.eq.nmods.and.
     &        nphase(m).lt.5) then
            mCOcore = xmHet(m)
            iCOcore = m
         endif

         !the C-burning ends when nphase=7 and |LNe| > 2xLC (Ne ignition)
         !or when nphase>=5 and Tmax<TburnC and X(12C) < .1

         if (istartC.ne.nmods.and.
     &        ((nphase(m).ge.7.and.abs(lne(m)).gt.2.d0*lc(m)) .or.
     &        (nphase(m).ge.5.and.tmax(m).lt.TburnC.and.
     &        (xspc(m,ic12).lt.1.d-1.or.lc(m).lt.1.d1)).or.
     &        abs(lne(m)).gt.1.d8)) then 

cok         if ((nphase(m).ge.7 .and. abs(lne(m)).gt.2.d0*lc(m)) .or.
cok     &        (istartC.ne.nmods .and. nphase(m).ge.5 .and. 
cok     &        tmax(m).lt.TburnC.and.xspc(m,ic12).lt.1.d-1)) then 

!     &        (istartC.ne.nmods .and. xspc(m,ic12).lt.1.2d-1 .and.
!     &        nphase(m).gt.5 .and. tmax(m).lt.TburnC)) then
!         if (nphase(m).eq.7.and.tmax(m).gt.9.89d8 .or.(istartC.ne.nmods
!     &        .and.xspc(m,ic12).lt.5.d-2.and.(nphase(m).eq.5.or.
!     &        tmax(m).lt.TburnC))) then
            iendC = m
            goto 40
         endif
      enddo


      !check for eventual AGB or SAGB phases
 40   if (abs(lne(iendC)).gt.lc(iendC) .and. 
     &     nphase(iendC).ge.6) then
         AGBphase = .false.
         SAGBphase = .false.
      else
         if (istartC.ne.nmods) then
            AGBphase = .false.
            SAGBphase = .true.           
            istartAGB = max(iDUP2,iendC)
         else
            AGBphase = .true.
            SAGBphase = .false.
            istartAGB = iDUP2
         endif
      endif

      !-----------------------------
      ! C-burning characteristics
      !-----------------------------

      mNeOcore = 0.d0
      iNeOcore = 0
c      mCOcore = mHecore
c      iCOcore = iHecore

      istartCcore = iendC
      iendCcore = iendC
      mCcore_conv = 0.d0
      nflame = 0
      iCcoremax = istartCcore
      iLCcoremax = istartCcore
      LCcoremax = LC(istartCcore)
      istartflame = iendC
      if (nphase(istartC).gt.6.or.istartC.eq.iendC) goto 50

      do m = istartC,iendC


         !Number of convective zones before of removing 
         !and merging. The possible convective envelope 
         !is not taken into account 
         ncz(m) = min(ncz(m),7)
         if (xmenvb(m).gt.0.d0) ncz(m) = ncz(m)-1


         !Calculate xmtop
         if (xmHeb(m).gt.0.d0) then
            xmtop = xmHeb(m)
         else
            xmtop = xmenvb(m)
         endif

         if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *,model(m),ncz(m)


         !Remove convective zones above the He shell burning
         !or, if the He shell burning is not present, remove
         !convective zones above the convective envelope
         if (xmb6(m).gt.xmtop.and.xmt6(m).gt.0.d0) then
            ncz(m)= ncz(m)-1
         endif
         if (xmb5(m).gt.xmtop.and.xmt5(m).gt.0.d0) then 
            ncz(m)= ncz(m)-1
         endif
         if (xmb4(m).gt.xmtop.and.xmt4(m).gt.0.d0) then
            ncz(m)= ncz(m)-1
         endif
         if (xmb3(m).gt.xmtop.and.xmt3(m).gt.0.d0) then
            ncz(m)= ncz(m)-1
         endif
         if (xmb2(m).gt.xmtop.and.xmt2(m).gt.0.d0) then 
            ncz(m)= ncz(m)-1
         endif
         if (xmb(m).gt.xmtop.and.xmt(m).gt.0.d0) then 
            ncz(m)= ncz(m)-1
         endif
         
         if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *,'*',model(m)
     &        ,ncz(m)

         !Remove convective zones (below xmtop) whose thickness 
         !in mass is < 1.d-3 (in some cases it is better to use 
         !1.d-2 instead of 1.d-3)
         if (xmb6(m).lt.xmtop .and. (xmt6(m)-xmb6(m)).lt.1.d-3
     &        .and.xmt6(m).gt.0.d0 ) then
            ncz(m)= ncz(m)-1
         endif
         if (xmb5(m).lt.xmtop .and. (xmt5(m)-xmb5(m)).lt.1.d-3
     &        .and.xmt5(m).gt.0.d0 ) then
            xmt5(m)= xmt6(m)
            xmb5(m)= xmb6(m)
            ncz(m)= ncz(m)-1
         endif
         if (xmb4(m).lt.xmtop .and. (xmt4(m)-xmb4(m)).lt.1.d-3
     &        .and.xmt4(m).gt.0.d0 ) then
            xmt4(m)= xmt5(m)
            xmb4(m)= xmb5(m)            
            xmt5(m)= xmt6(m)
            xmb5(m)= xmb6(m)            
            ncz(m)= ncz(m)-1
         endif
         if (xmb3(m).lt.xmtop .and. (xmt3(m)-xmb3(m)).lt.1.d-3
     &        .and.xmt3(m).gt.0.d0 ) then
            xmt3(m)= xmt4(m)
            xmb3(m)= xmb4(m)            
            xmt4(m)= xmt5(m)
            xmb4(m)= xmb5(m)            
            xmt5(m)= xmt6(m)
            xmb5(m)= xmb6(m)                      
            ncz(m)= ncz(m)-1
         endif
         if (xmb2(m).lt.xmtop .and. (xmt2(m)-xmb2(m)).lt.1.d-3
     &        .and.xmt2(m).gt.0.d0 ) then
            xmt2(m)= xmt3(m)
            xmb2(m)= xmb3(m)            
            xmt3(m)= xmt4(m)
            xmb3(m)= xmb4(m)            
            xmt4(m)= xmt5(m)
            xmb4(m)= xmb5(m)            
            xmt5(m)= xmt6(m)
            xmb5(m)= xmb6(m)                      
            ncz(m)= ncz(m)-1
         endif
         if (xmb(m).lt.xmtop .and. (xmt(m)-xmb(m)).lt.1.d-3
     &        .and.xmt(m).gt.0.d0 ) then
            xmt(m)= xmt2(m)
            xmb(m)= xmb2(m)                      
            xmt2(m)= xmt3(m)
            xmb2(m)= xmb3(m)            
            xmt3(m)= xmt4(m)
            xmb3(m)= xmb4(m)            
            xmt4(m)= xmt5(m)
            xmb4(m)= xmb5(m)            
            xmt5(m)= xmt6(m)
            xmb5(m)= xmb6(m)                      
            ncz(m)= ncz(m)-1
         endif

         if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *,'**',model(m)
     &        ,ncz(m),xmb(m),xmb2(m)
         !Merge the convective zones whose distance in mass is < 1.d-2
         if (ncz(m).ge.6 .and. xmt6(m).gt.1.d-11 .and. 
     &        xmb6(m)-xmt5(m).lt.1.d-2) then
            xmt5(m)= xmt6(m)
            ncz(m)= ncz(m)-1
         endif
         if (ncz(m).ge.5 .and. xmt5(m).gt.1.d-11 .and. 
     &        xmb5(m)-xmt4(m).lt.1.d-2) then
            xmt4(m) = xmt5(m)
            xmb5(m) = xmb6(m)
            xmt5(m) = xmt6(m)
            ncz(m) = ncz(m)-1
         endif
         if (ncz(m).ge.4 .and. xmt4(m).gt.1.d-11 .and. 
     &        xmb4(m)-xmt3(m).lt.1.d-2) then
            xmt3(m) = xmt4(m)
            xmb4(m) = xmb5(m)
            xmt4(m) = xmt5(m)
            xmb5(m) = xmb6(m)
            xmt5(m) = xmt6(m)
            ncz(m) = ncz(m)-1
         endif
         if (ncz(m).ge.3 .and. xmt3(m).gt.1.d-11 .and. 
     &        xmb3(m)-xmt2(m).lt.1.d-2) then
            xmt2(m) = xmt3(m)
            xmb3(m) = xmb4(m)
            xmt3(m) = xmt4(m)
            xmb4(m) = xmb5(m)
            xmt4(m) = xmt5(m)
            xmb5(m) = xmb6(m)
            xmt5(m) = xmt6(m)
            ncz(m) = ncz(m)-1
         endif
         if (ncz(m).ge.2 .and. xmt2(m).gt.1.d-11 .and. 
     &        xmb2(m)-xmt(m).lt.1.d-2) then
            xmt(m) = xmt2(m)
            xmb2(m) = xmb3(m)
            xmt2(m) = xmt3(m)
            xmb3(m) = xmb4(m)
            xmt3(m) = xmt4(m)
            xmb4(m) = xmb5(m)
            xmt4(m) = xmt5(m)
            xmb5(m) = xmb6(m)
            xmt5(m) = xmt6(m)
            ncz(m) = ncz(m)-1
         endif
         if (ncz(m-1).eq.0.and.ncz(m).eq.1.and.ncz(m+1).ge.1.and.
     &        (xmb(m).gt.xmt(m+1).or.xmt(m).lt.xmb(m+1))) then
            xmb(m) = 0.d0
            xmt(m) = 0.d0
            ncz(m) = 0
         endif

         if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *,'***',model(m)
     &        ,ncz(m),xmb(m),xmt(m),xmt(m+1),xmt2(m+1),ncz(m+1)


*------------------------------
*** COMPUTE PHYSICAL QUANTITIES
*------------------------------


         !define beginning and size of carbon convective core burning
         if (istartCcore.eq.iendC.and.xrb(m).eq.0.d0.and.xmt(m).gt.
     &        1.d-5) istartCcore = m
         if (istartCcore.ne.iendC.and.iendCcore.eq.iendC) then
            if (xmt(m).eq.0.d0) iendCcore = m
            if (xmt(m).gt.mCcore_conv) then
               mCcore_conv = xmt(m)
               iCcoremax = m
            endif
            if (LC(m).gt.LCcoremax) then
               LCcoremax = LC(m)
               iLCcoremax = m
            endif
         endif
         
         !calculate the mass of the Ne-O core.
         !mNeOcore = max(mNeOcore,xmCt(m))
         if (mNeOcore.le.xmCt(m)) then
            mNeOcore = xmCt(m)
            iNeOcore = m
         endif
c          if (mCOcore.le.xmHet(m)) then
c             mCOcore = xmHet(m)
c             iCOcore = m
c          endif
           
             
         !define presence of flame
c1         itp(m) = lc(m).gt.1.d2 .and. xtb(m).gt.lTburnC .and. xrt(m).gt.
c1     &        1.d-11
c2         itp(m) = lc(m).gt.1.d2 .and. xrt(m).gt. 0.d0 .and. xmb(m).ge.
c2     &        xmCb(m).and.ncz(m).gt.0
         itp(m) = lc(m).gt.1.d2 .and. xmt(m).ge. xmCb(m).and.ncz(m).gt.0
         if (istartflame.eq.iendC.and.itp(m)) istartflame = m
         if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *,m,'itp',itp(m)
      enddo
 

      !if the core C-burning doesn't occur then mNeOcore=0
      if (istartC.eq.iendC .and. istartC.eq.nmods) then 
         mNeOcore=0.d0
      endif


      !treatment of flames
      if (istartflame.ne.iendC) then
         nflame = 0
         nflame2 = 0
         twoflames = .false.
         nflame_cur = 0
         simultaneous = .false.

         do m = istartflame,iendC-1

            !Re-calculate xmtop 
            if (xmHeb(m).gt.0.d0) then
               xmtop = xmHeb(m)
            else
               xmtop = xmenvb(m)
            endif            

            !only one flame in a given model
            if (.not.twoflames.and.(itp(m).and..not.itp(m-1).or.
     &           simultaneous)) then
               nflame_cur = 1
               nflame = nflame+1
               nflame1 = nflame
               iCstart(nflame1) = m
               iCend(nflame1) = nmods
               mCigni(nflame1) = xmb(m)
               mCmin(nflame1) = mCigni(nflame1)
               mCmax(nflame1) = mCigni(nflame1)
               if (debug) print *,'in1' ,model(m),'nf1=' ,nflame1,'nf2='
     &              ,nflame2,nflame ,'ncz=',ncz(m),ncz(m-1),'twoflames='
     &              ,twoflames ,mCigni(nflame1)


            !two flames in a given model
            elseif (ncz(m).gt.ncz(m-1).and.xmb2(m).lt.xmtop .and.
     &              nflame_cur.eq.1.and.ncz(m).le.3) then
               nflame_cur = 2
               nflame = nflame+1
               twoflames = .true.
               below = .false.


               !the 2nd conv. zone (or flame) develops below the 1st one,
               !in this case below is "true"
               if (xmt(m).lt.xmb(m-1)) below = .true.
               nflame2 = nflame
               iCstart(nflame2) = m
               iCend(nflame2) = nmods

               !calculate mCigni and initialize mCmin(max)
               if (below) then
                  mCigni(nflame2) = xmb(m)
               else
                  mCigni(nflame2) = xmb2(m)
               endif
               mCmin(nflame2) = mCigni(nflame2)
               mCmax(nflame2) = mCigni(nflame2)
               if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *,'in2'
     &              ,model(m),'nf1=',nflame1,'nf2=',nflame2,nflame,below
     &              ,'ncz=',ncz(m-1),ncz(m),ncz(m+1),twoflames,itp(m)
     &              ,itp(m-1),mCigni(nflame2),mCigni(nflame1) ,xmtop
     &              ,xmb(m),xmb(m-1),xmt(m),xmt(m-1)

c..   case flame develops while a another secondary CZ is already declared
            elseif (nflame_cur.eq.2.and.xmt(m).lt.xmb(m-1)) then
               below = .true.
               if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *,'in3'
     &              ,model(m),'nf1=',nflame1,iCstart(nflame1),'nf2='
     &              ,iCstart(nflame2),nflame2,nflame,below ,'ncz=',ncz(m
     &              -1),ncz(m),ncz(m+1),twoflames,itp(m) ,itp(m-1)
     &              ,mCigni(nflame2),mCigni(nflame1),xmb(m)
     &              ,xmb(m-1),xmt(m),xmt(m-1)
               iCstart(nflame2) = m
               iCend(nflame2) = nmods               
               mCigni(nflame2) = xmb(m)
               mCmin(nflame2) = mCigni(nflame2)
               mCmax(nflame2) = mCigni(nflame2)               
            endif

            
            !calculate mCmin and mCmax  
            if (nflame.gt.0.and.itp(m)) then
               if (twoflames) then
                  if (below) then
                     mCmin(nflame2) = min(xmb(m),mCmin(nflame2))
                     mCmax(nflame2) = max(xmt(m),mCmax(nflame2))
                     !lCmax(nflame2) = max(lc(m),lCmax(nflame2))
                     mCmin(nflame1) = min(xmb2(m),mCmin(nflame1))
                     mCmax(nflame1) = max(xmt2(m),mCmax(nflame1))
                     !lCmax(nflame1) = max(lc(m),lCmax(nflame1))
                  else
                     mCmin(nflame1) = min(xmb(m),mCmin(nflame1))
                     mCmax(nflame1) = max(xmt(m),mCmax(nflame1))
                     !lCmax(nflame1) = max(lc(m),lCmax(nflame1))
                     mCmin(nflame2) = min(xmb2(m),mCmin(nflame2))
                     mCmax(nflame2) = max(xmt2(m),mCmax(nflame2))
                     !lCmax(nflame2) = max(lc(m),lCmax(nflame2))
                  endif               
               else
                  mCmin(nflame1) = min(xmb(m),mCmin(nflame1))
                  mCmax(nflame1) = max(xmt(m),mCmax(nflame1))
                  !lCmax(nflame1) = max(lc(m),lCmax(nflame1))
               endif
            endif


            !Check if one of the two flames ends
            if (twoflames.and.ncz(m+1).lt.ncz(m).and.xmb2(m).lt.
     &           xmtop.and.ncz(m+1).le.3) then

               !Calculate the upper and lower boundary of the two flames
               if (below) then
                  mb2 = xmb(m)
                  mt2 = xmt(m)
                  mb1 = xmb2(m)
                  mt1 = xmt2(m)
               else
                  mb2 = xmb2(m)
                  mt2 = xmt2(m)
                  mb1 = xmb(m)
                  mt1 = xmt(m)
               endif


               !Determine which CZ is closing
               if ((.not.below .and. xmb(m+1).gt.mt1)
     &              .or. (below .and. xmt(m+1).lt.mb1)) then
                  jj = nflame1
               else
                  jj = nflame2         
               endif

                     
               !Initialize ndel
               if (m.lt.iendCcore) then
                  ndel = 30
               else
                  ndel = 15
               endif


               !Calculate iCend if the duration of the convective zone is
               !greater than ndel models and if Mmin, Mmax are both non 
               !equal to zero 
               if (m-iCstart(jj).gt.ndel .and. mCmax(jj).lt.xmtop
     &              .and. mCmax(jj).gt.1.d-4
     &              .and. time(m)-time(iCstart(jj)).gt.1.d-1
     &              .and. ((mCmax(jj)-mCmin(jj)).gt.5.d-4)) then
                  if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *
     &                 ,'closing 2 cz ',jj,'nf1 =',nflame1,'nf2='
     &                 ,nflame2,nflame,below ,model(iCstart(jj)),model(m
     &                 ),iendC,twoflames
                  iCend(jj) = m
                  if (jj.eq.nflame1) nflame1 = nflame2

               

               !Remove the convective zone if its duration is less than
               !ndel models or if Mmin, Mmax are both equal to zero   
               else
                  if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *
     &                 ,'deleting 2 cz ?',jj,'nf1= ',nflame1 ,'nf2='
     &                 ,nflame2,nflame,below,model(iCstart(jj)) ,model(m
     &                 ),nflame1 ,nflame2,twoflames,mcigni(nflame1)
     &                 ,mcigni(nflame2)
                  if (jj.eq.nflame1) then
                     iCstart(nflame1) = iCstart(nflame2)
                     iCend(nflame1) = iCend(nflame2)
                     mCigni(nflame1) = mCigni(nflame2)
                     mCmin(nflame1) = mCmin(nflame2)
                     mCmax(nflame1) = mCmax(nflame2)
                  else
                     iCstart(jj) = 0
                     iCend(jj) = 0
                     mCigni(jj) = 0.d0
                     mCmin(jj) = 0.d0
                     mCmax(jj) = 0.d0
                  endif
                  nflame = nflame-1
               endif              
               nflame_cur = 1
               twoflames = .false.

            endif
               


            !Calculate iCend if the duration of the convective zone is
            !greater than ndel models (in the case of one convective zone)
c            if (itp(m-1).and..not.itp(m).and..not.twoflames) then
          

            simultaneous = itp(m-1).and.itp(m).and.
     &           ncz(m).eq.ncz(m-1).and.ncz(m).eq.1
     &           .and.(xmt(m).lt.xmb(m-1).or.xmb(m).gt.xmt(m-1))
            if (debug.and.m.gt.jsh1.and.m.lt.jsh2) print *,'simul',m
     &           ,itp(m-1),itp(m),xmt(m),xmb(m-1),xmb(m),xmt(m-1)
     &           ,twoflames,simultaneous,ncz(m),ncz(m-1)

            if (.not.twoflames.and.(itp(m-1).and..not.itp(m).or.
     &           simultaneous)) then

               !Re-initialize ndel for only one
               !convective zone 
               if (m.lt.iendCcore) then
                  ndel = 30
               else
                  ndel = 10
               endif


               !Remove a short-lived convective zone and a convective 
               !zone with both Mmin and Mmax equal to zero         
               if (m-iCstart(nflame1).gt.ndel .and. 
     &              mCmax(nflame1) .gt. 1.d-4 .and.
     &              ((mCmax(nflame1)-mCmin(nflame1)).gt.5.d-4)) then
                  iCend(nflame1) = m
                  if (debug) print *,'closing 1 cz, nf1=',nflame1 ,
     &                 'nf2=',nflame2,nflame,below,model(iCstart(nflame1
     &                 )),model(m),twoflames,mCigni(nflame1),itp(m)
     &                 ,itp(m -1)
               else
                  if (debug) print *,'WARNING deleting cz, nf1='
     &                 ,nflame1,'nf2=',nflame2,nflame,below
     &                 ,model(iCstart(nflame1)) ,model(m),twoflames
     &                 ,itp(m),itp(m -1)
                  iCstart(nflame1) = 0
                  iCend(nflame1) = 0
                  mCigni(nflame1) = 0.d0
                  mCmin(nflame1) = 0.d0
                  mCmax(nflame1) = 0.d0
                  nflame = nflame-1
               endif
               nflame_cur = 0
               twoflames = .false.
            endif
         enddo
      endif
 
    
      !Calculate lCmax if there are flames
      if (nflame .gt. 0) then
         do k = 1,nflame
            lCmax(k)=0.d0
            ilCmax(k) = 0
            do pp=iCstart(k), iCend(k)
               if (lc(pp).gt.lCmax(k)) then
                  lCmax(k)=lc(pp)
                  ilCmax(k) = pp
               endif
            enddo
            mNeOcore = max(mNeOcore,mCmax(k))
         enddo
      endif
 
     
     
      !Calculate dtC, dtCcore_conv
 50   dtC = time(iendC)-time(istartC)
      dtCcore_conv = time(iendCcore)-time(istartCcore)
      if (dtCcore_conv.lt.1.d-1) mCcore_conv = 0.d0

      
!----------------------------------------------------------------
! THERMAL PULSE DETECTION AND COMPUTATION OF RELATED QUANTITIES
!----------------------------------------------------------------


      if (istartAGB.ge.(nmods-1)) then
         write (*,*) 'No AGB phase !'
         goto 120
      endif

      if (SAGBphase.and.istartAGB.lt.min(istartC,iDUP2).and.
     &     istartAGB.lt.nmods) then
         print *,'PROBLEM : start super-AGB phase (',istartAGB,
     &        ') before beginning of C burning phase (',istartC,')!!'
         stop
      endif

      iAGB = istartAGB
      iSAGB = istartAGB
      iHflash = 0
      if (.not.(AGBphase.or.SAGBphase)) goto 120
      do m = istartAGB,iendAGB
c..  merge small convective zones in the pulse region
         if (lgrav(m).le.0.d0) then            
            xmtop = xmHet(m)
            if (xmt6(m).gt.1.d-11 .and. xmb6(m).lt.xmtop.and. 
     &           xmb6(m)-xmt5(m).lt.1.d-2) then
               xmt5(m)= xmt6(m)
               xmt6(m) = 0.d0
               xmb6(m) = 0.d0
               ncz(m)= ncz(m)-1
            endif
            if (xmt5(m).gt.1.d-11 .and. xmb5(m).lt.xmtop.and. 
     &           xmt6(m).gt.0.d0.and.xmb6(m).lt.xmtop.and.
     &            xmb5(m)-xmt4(m).lt.1.d-2) then
               xmt4(m) = xmt5(m)
               xmb5(m) = xmb6(m)
               xmt5(m) = xmt6(m)
               xmt6(m) = 0.d0
               xmb6(m) = 0.d0
               ncz(m)= ncz(m)-1
            endif
            if (xmt4(m).gt.1.d-11 .and. xmb4(m).lt.xmtop.and. 
     &           xmt5(m).gt.0.d0.and.xmb5(m).lt.xmtop.and.
     &           (xmt4(m)-xmb4(m)).lt.1.d-3) then
               xmt4(m)= xmt5(m)
               xmb4(m)= xmb5(m)            
               xmt5(m)= xmt6(m)
               xmb5(m)= xmb6(m)            
               xmt6(m) = 0.d0
               xmb6(m) = 0.d0
               ncz(m)= ncz(m)-1
            endif
            if (xmt3(m).gt.1.d-11 .and. xmb3(m).lt.xmtop.and. 
     &           xmt4(m).gt.0.d0.and.xmb4(m).lt.xmtop.and.
     &           (xmt3(m)-xmb3(m)).lt.1.d-3) then
               xmt3(m)= xmt4(m)
               xmb3(m)= xmb4(m)            
               xmt4(m)= xmt5(m)
               xmb4(m)= xmb5(m)            
               xmt5(m)= xmt6(m)
               xmb5(m)= xmb6(m)                      
               xmt6(m) = 0.d0
               xmb6(m) = 0.d0
               ncz(m)= ncz(m)-1
            endif
            if (xmt2(m).gt.1.d-11 .and. xmb2(m).lt.xmtop.and. 
     &           xmt3(m).gt.0.d0.and.xmb3(m).lt.xmtop.and.
     &           (xmt2(m)-xmb2(m)).lt.1.d-3) then
               xmt2(m)= xmt3(m)
               xmb2(m)= xmb3(m)            
               xmt3(m)= xmt4(m)
               xmb3(m)= xmb4(m)            
               xmt4(m)= xmt5(m)
               xmb4(m)= xmb5(m)            
               xmt5(m)= xmt6(m)
               xmb5(m)= xmb6(m)                      
               xmt6(m) = 0.d0
               xmb6(m) = 0.d0
               ncz(m)= ncz(m)-1
            endif
c            if (model(m).gt.441573.and.model(m).lt.441714) print *,'1'
c     &           ,model(m),xmb(m),xmt(m),xmb2(m),xmt2(m),xmtop,ncz(m)
            if ((xmt(m).gt.1.d-11.and.xmb(m).lt.xmtop.and. 
     &           xmt2(m).gt.0.d0.and.xmb2(m).lt.xmtop.and.
     &           (xmt(m)-xmb(m)).lt.1.d-3).or.
     &           (xmt(m).eq.0.d0.and.xmt2(m).gt.0.d0)) then
               xmt(m)= xmt2(m)
               xmb(m)= xmb2(m)                      
               xmt2(m)= xmt3(m)
               xmb2(m)= xmb3(m)            
               xmt3(m)= xmt4(m)
               xmb3(m)= xmb4(m)            
               xmt4(m)= xmt5(m)
               xmb4(m)= xmb5(m)            
               xmt5(m)= xmt6(m)
               xmb5(m)= xmb6(m)                      
               xmt6(m) = 0.d0
               xmb6(m) = 0.d0
               ncz(m)= ncz(m)-1
            endif            

         endif

***  define presence of pulse
*----------------------------
c         itp(m) = lhe(m).gt.1.d3.and.(xtb(m).gt.8.176d0.or.xmb(m)
c     &        .gt.1.d-11).and.xmb(m).lt.xmHet(m)
         itp(m) = xmb(m).lt.xmHet(m).and.xmb(m).gt.0.d0
         icz(m) = .false.
c         if (xmb2(m).gt.1.d-11.and.xmt2(m).lt.xmHb(m).and.lh(m).lt.1.d8)
c     &        icz(m)=.true.
         if (xmb2(m).gt.1.d-11.and.xmt2(m).lt.xmHb(m)) icz(m)=.true.
c         if (lh(m).gt.1.d7.and.nphase(m).gt.4) iHflash = m
c          if (model(m).gt.682180.and.model(m).lt.682200) print *,model(m)
c      &        ,xmb(m),xmHet(m),itp(m),icz(m)
      enddo

      npuls = 0
      imod = istartAGB
      ibegtp = nmods+1

 101  do m = imod+1,nmods-1
         m1 = m-1
         m2 = m+1
         if (xmb(m).ge.1.d-11.and.xmb(m1).lt.1.d-11.and.xmb(m2).ge.
     &        1.d-11.and.xmb(m).lt.xmHet(m).and.lh(m).gt.1.d2.and.
     &        lh(m).lt.1.d8) goto 102
c         if (xmb(m).ge.1.d-11.and.xmb(m1).lt.1.d-11.and.xmb(m2).ge.
c     &        1.d-11.and.xmb(m).lt.xmHet(m).and.lh(m).gt.1.d2.and.
c     &        icz(m)) goto 102
      enddo

 102  npuls = npuls+1
      if (npuls.le.1.and.m.ge.(nmods-1)) then
         write (*,*) 'No TP-AGB phase !'
         goto 120
      endif
      if (npuls.eq.1) then
         ibegtp = m
         t0 = time(ibegtp-10)
      endif
      mbeg(npuls) = m
      eta_He(npuls) = xetaHem(m-1)
      pulse_mHeBS(npuls) = xmHet(m-1)-xmHeb(m-1)
      pulse_rHeBS(npuls) = xrHet(m-1)-xrHeb(m-1)
      rHeBS(npuls) = xrHeb(m-1)
      do m = mbeg(npuls)+1,nmods-1
         m1 = m-1
         m2 = m+1
c         if (xmb(m).lt.1.d-11.and.xmb(m1).ge.1.d-11.and.xmb(m2).lt.
c     &        1.d-11) goto 103
c         dtp = time(m)-time(mbeg(npuls))
c          if (model(m).gt.682164.and.model(m).lt.682200) print *,model(m)
c      &        ,xmb(m),xmt(m),xmHet(m),itp(m),itp(m2)
         if (itp(m).and..not.itp(m2)) goto 103
      enddo

 103  mend(npuls) = m
      if (m-mbeg(npuls).lt.4) then
         npuls = npuls-1
         if (m.ge.(nmods-1)) then
            goto 105
         else
            imod = m+1
            goto 101            
         endif
      endif
      mtpul(npuls) = -1.d99
      mtop(npuls) = -1
      tbmax(npuls) = 10.d0**xtb(mbeg(npuls))
      ttmax(npuls) = 10.d0**xtt(mbeg(npuls))
      robmax(npuls) = 10.d0**xrob(mbeg(npuls))
      rotmax(npuls) = 10.d0**xrot(mbeg(npuls))
      do m = mbeg(npuls)+1,mend(npuls)-1
         tbmax(npuls) = max(10.d0**xtb(m),tbmax(npuls))
         ttmax(npuls) = min(10.d0**xtt(m),ttmax(npuls))
         robmax(npuls) = max(10.d0**xrob(m),robmax(npuls))
         rotmax(npuls) = min(10.d0**xrot(m),rotmax(npuls))
         if (xmt(m).gt.mtpul(npuls).and..not.icz(m)) then
            mtpul(npuls) = xmt(m)
            mtop(npuls) = m
         endif
      enddo
      mbpul(npuls) = 1.d99
      mbot(npuls) = -1
      do m = mbeg(npuls)+1,mend(npuls)-1
         if (xmb(m).lt.mbpul(npuls).and.xmb(m).gt.1.d-11.and.
     &        .not.icz(m)) then
            mbpul(npuls) = xmb(m)
            mbot(npuls) = m
         endif
      enddo
      lhemax(npuls) = -1.d99
      do m = mbeg(npuls)+1,mend(npuls)-1
         if (lhe(m).gt.lhemax(npuls)) then
            lhemax(npuls) = lhe(m)
            lhmax(npuls) = lh(m)
         endif
      enddo
      if (mend(npuls).lt.(nmods-100)) then
         imod = mend(npuls)+1
         goto 101
      else
         goto 105
      endif

 105  mbeg(npuls+1) = nmods
      do i = 1,npuls
         i1 = i+1
         i2 = i-1

*------------------------
*** pulse characteristics
*------------------------

         modbeg(i) = model(mbeg(i))
         modtop(i) = model(mtop(i))
         modend(i) = model(mend(i))
         tbeg(i) = time(mbeg(i))
c..  stellar parameters at pulse start
         mtotbeg(i) = mtot(mbeg(i))
         lbeg(i) = leff(mbeg(i))
         rbeg(i) = reff(mbeg(i))
         mlbeg(i) = mloss(mbeg(i))
c..  pulse duration
         dtpul(i) = time(mend(i))-time(mbeg(i))
         dnmod = int((mbeg(i1)-mend(i))*0.002)
         if (dnmod.lt.2) dnmod = 2
c..  rho/T at max pulse extension
c         tbmax(i) = 10.d0**(xtb(mtop(i)))
c         ttmax(i) = 10.d0**(xtt(mtop(i)))
c         robmax(i) = 10.d0**(xrob(mtop(i)))
c         rotmax(i) = 10.d0**(xrot(mtop(i)))
c.. core mass at the beginning of the pulse
         Mcore_pul(i) = xmHeb(mbeg(i))
         if (Mcore_pul(i).lt.1.d-2) Mcore_pul(i) = xmHb(mbeg(i))
c.. maximum extension of pulse (Mpulse_base,min - M_pulse_top,max)
         dmpulmax(i) = mtpul(i)-mbpul(i)

c.. interpulse duration
         if (i.eq.npuls) then
            dtintpul(i) = 1.d0
         else
            dtintpul(i) = time(mbeg(i1))-time(mend(i))
         endif

*---------------------------
*** envelope characteristics
*---------------------------

c.. determine DUP characteristics
         dup_Mb(i) = 1.d99
         do j = mend(i)+1,mbeg(i1)-1
            if (xmenvb(j).lt.dup_Mb(i)) then
               mdup(i) = j
               moddup(i) = model(mdup(i))
               dup_Mb(i) = xmenvb(j)
               dup_Tb(i) = 10.d0**xtenvb(j)
            endif
         enddo
         do j = mdup(i)+1,mbeg(i1)-1
            if (lh(j).gt.10.d0*lhe(j)) goto 106
         enddo
 106     mdupcn(i) = j
c..  is 3DUP activated ?
         dupH(i) = 0
         if (mtpul(i).gt.dup_Mb(i)) dupH(i) = 1
c..  mass if the 3DUP
         if (dupH(i).eq.1) then
            dup_dm(i) = mtpul(i)-dup_Mb(i)
c            dup_dm(i) = xmenvb((mbeg(i)-dnmod))-dup_Mb(i)
c            dup_dm(i) = xmHm((mbeg(i)-dnmod))-dup_Mb(i)
         else
            dup_dm(i) = 0.d0
         endif

c..  compute lambda
c.. true definition : lambda = delta M_H/delta M_DUP
c c..  reactivation of HBS
c          if (i.gt.1.and.mHa(i).gt.0) then
c            if (i.gt.1) then
c cl              do j = mend(i2)+1,mbeg(i)-1
c               do j = mdup(i2)+1,mbeg(i)-1
c                  if (lh(j).gt.1.d1.and.lh(j-1).lt.1.d1) goto 107
c               enddo
c    107        mHa(i) = j
c            else
c               mHa(i) = -1
c            endif
c            dmHpul(i) = xmHm((mbeg(i)-dnmod))-xmHm(mHa(i))
c            if (dmHpul(i).lt.1.d-10) dmHpul(i) = xmHm((mbeg(i)-dnmod))-
c     &           dup_Mb(i2)
c            lambda(i) = dup_dm(i)/dmHpul(i)
         if (i.gt.1) then
            dmHpul(i) = max(mtpul(i)-dup_Mb(i2),0.d0)
         else
            dmHpul(i) = 0.d0
         endif
         if (dupH(i).eq.1) then
            lambda(i) = dup_dm(i)/dmHpul(i)
         else
            lambda(i) = 0.d0
         endif
c..  dilution factor
         if (dupH(i).eq.1) then
            fdilu(i) = dup_dm(i)/dmpulmax(i)
         else
            fdilu(i) = 0.d0
         endif
c..  pulse overlap factor
         if (i.gt.1) then
            foverlap(i) = (min(mtpul(i2),dup_Mb(i2))-mbpul(i))/
     &           dmpulmax(i)
         else
            foverlap(i) = 0.d0
         endif
      enddo
      if(npuls.gt.1) then
         ipw = int(log10(dtintpul(npuls-1)))
      else
         ipw = 0
      endif
      dt0 = 10.d0**ipw


      !--------------------------
      ! Compute YIELDS
      !--------------------------
      
      do i = 1,nspi
         eject(i) = 0.d0
      enddo
      Mwind = mtot(1)-mtot(nmods)
      Menv = mtot(nmods)-xmenvb(nmods)
      zini = 1.d0-xsps(1,2)-xsps(1,3)-xsps(1,4)-xsps(1,5)
      do j = 2,nmods
         dM = mtot(j-1)-mtot(j)
         do i = 1,nspi
            eject(i) = eject(i)+dM*xsps(j,i)
         enddo
      enddo
      do i = 1,nspi
         ejectEC(i) = eject(i)+Menv*xsps(nmods,i)
         yield(i) = eject(i)-Mwind*xsps(1,i)
         yieldEC(i) = yield(i)+Menv*(xsps(nmods,i)-xsps(1,i))
      enddo
      
      open (unit = 61, file = seqname(1:lenc(seqname)) // '.yields',
     &     action = 'write' , status = 'unknown')
      write (61,4000) MWind,Menv,mtot(1),zini
      write (61,4010)
      do  i = 1,nspi
         write (61,4020) chemi(i),eject(i),yield(i),ejectEC(i),
     &        yieldEC(i)
      enddo


      !--------------------------
      ! Storage of the results
      !--------------------------


      !Create files '.tpagb0', '.tpagb1', '.tpagb2', '.tpagb3', '.out'
      open (unit = 30, file = seqname(1:lenc(seqname)) // '.tpagb0',
     &     action = 'write' , status = 'unknown')
      open (unit = 31, file = seqname(1:lenc(seqname)) // '.tpagb1',
     &     action = 'write' , status = 'unknown')
      open (unit = 32, file = seqname(1:lenc(seqname)) // '.tpagb2',
     &     action = 'write' , status = 'unknown')
      open (unit = 33, file = seqname(1:lenc(seqname)) // '.tpagb3',
     &     action = 'write' , status = 'unknown')
      open (unit = 35, file = seqname(1:lenc(seqname)) // '.out',
     &     action = 'write' , status = 'unknown')

      write (30,3000) t0,dt0,ttot
      write (31,3100)
      write (32,3200)
      write (33,3300)
      do i = 1,npuls
         nseq1 = nseq(mdup(i))
         xmenv1 = xmenvb(modseq(nseq1))
         nseq2 = nseq1+1
         if (nseq2.gt.mcar) then
            xmenv2 = xmenvb(nmods)
         else
            xmenv2 = xmenvb(modseq(nseq2))
         endif
         if (xmenv2.lt.xmenv1) nseq1 = nseq2
         if (i.lt.npuls) then
            j = int((mbeg(i+1)+mbeg(i))/2)
         else
            j = int((mbeg(i-1)+mbeg(i))/2)
         endif
         write (31,3101) i,modbeg(i),nseq(mbeg(i)),modtop(i),
     &        nseq(mtop(i)),modend(i),nseq(mend(i)),moddup(i),
     &        nseq1,tbeg(i),dtpul(i),dtintpul(i),eta_He(i),
     &        rHeBS(i),10.d0**xtenvb(j)
         write (32,3201) i,mtotbeg(i),lbeg(i),rbeg(i),mlbeg(i),
     &        tbmax(i),ttmax(i),robmax(i),rotmax(i),pulse_mHeBS(i),
     &        pulse_rHeBS(i)
         if (i.lt.npuls) then
            j = mdup(i+1)-mdup(i)
            dMcore = (xmenvb(mbeg(i+1)-1)-xmenvb(mdup(i)))/dtintpul(i)
            dMcore_eff = (xmenvb(mdup(i+1))-xmenvb(mdup(i)))/dtintpul(i)
         else
            dMcore = 0.d0
         endif
         write (33,3301) i,Mcore_pul(i),mbpul(i),lhemax(i),dmpulmax(i),
     &        fdilu(i),foverlap(i),dupH(i),dup_dm(i),lambda(i),
     &        dmHpul(i),dup_Tb(i),dMcore,dMcore_eff
      enddo
c      write (34,3400)
c      do j = 1,nspi
c         write (34,3401) chemi(j),yields(j)
c      enddo
      do i = 1,npuls-1
         mHtn = xmHt(mbeg(i+1)-1)
         if (mHtn.lt.1.d-2) mHtn = xmenvb(mbeg(i+1)-1)
         write (35,3501) i,nseq(mbeg(i))-1,nseq(mend(i))+1,
     &        nseq(mdup(i))+1,nseq(mdupcn(i))+1,nseq(mbeg(i+1))-1,
     &        mbpul(i),mtpul(i),dup_Mb(i),mbpul(i+1),mHtn
      enddo

 120  mHBS = 0.d0
      mHeBS = 0.d0
      mCBS = 0.d0
      mHBS_Ms = 0.d0
      mHBS_He = 0.d0
      mHBS_CB = 0.d0
      mHeBS_He = 0.d0
      mHeBS_CB = 0.d0
      mCBS_CB = 0.d0
      mHBS_DUP1 = 0.d0
      mHBS_DUP2 = 0.d0
      mHeBS_DUP2 = 0.d0
      mCBS_DUP2 = 0.d0
      iHeBS = 0
      iCBS = 0
      do i = 1,nmods
         if (xspc(i,ih1).lt.0.5d0) then
            if (mHBS.lt.xmHm(i)) then
               iHBS = i
               mHBS = xmHm(i)
            endif
            if (mHBS.gt.xmenvb(i).and.xmenvb(i).gt.0.d0) then
               iHBS = i
               mHBS = xmenvb(i) 
            endif
            if (mHeBS.lt.xmHem(i)) then
               iHeBS = i
               mHeBS = xmHem(i)
            endif
            if (mHeBS.gt.xmenvb(i).and.xmenvb(i).gt.0.d0) then
               iHeBS = i
               mHeBS = xmenvb(i) 
            endif
            if (mCBS.lt.xmCm(i)) then
               iCBS = i
               mCBS = xmCm(i)
            endif
         endif
         if (nphase(i).gt.2.and.mHBS_Ms.eq.0.d0) then
            iHBS_MS = iHBS
            mHBS_MS = mHBS
         endif
         if (nphase(i).gt.4.and.mHBS_He.eq.0.d0) then
            iHBS_He = iHBS
            mHBS_He = mHBS
         endif

         if (nphase(i).gt.4.and.mHeBS_He.eq.0.d0) then
            iHeBS_He = iHeBS
            mHeBS_He = mHeBS
         endif

         if (i.eq.iendC) then 
            mHBS_CB = mHBS
            iHBS_CB = iHBS
            mHeBS_CB = mHeBS
            iHeBS_CB = iHeBS
            mCBS_CB = mCBS
            iCBS_CB = iCBS
         endif
        
         if (i.eq.iDUP1) then
            iHBS_DUP1 = iHBS
            mHBS_DUP1 = mHBS
         endif

         if (i.eq.iDUP2) then
            iHBS_DUP2 = iHBS
            mHBS_DUP2 = mHBS
            iHeBS_DUP2 = iHeBS
            mHeBS_DUP2 = mHeBS
            iCBS_DUP2 = iCBS
            mCBS_DUP2 = mCBS           
         endif
         
      enddo

      zini = 1.d0-xsps(1,2)-xsps(1,3)-xsps(1,4)-xsps(1,5)
      !Create file '.info'
      open (unit = 36, file = seqname(1:lenc(seqname)) // '.info',
     &     action = 'write' , status = 'unknown')

      write (36,3600) mtot(1),zini,seqname(1:lenc(seqname))
      if (istartH.eq.1.and.iendH.eq.1) goto 31
      write (36,3601) model(istartH),model(iendH),dtH,model(iHcore),
     &     mHcore
      write (36,3602) mHBS_MS,model(iHBS_MS)
      write (36,3603) xspc(iendH,ihe4),xspc(iendH,ic12),
     &     xspc(iendH,in14),xspc(iendH,io16)
 31   if (idup1.eq.1.and.istartRGB.eq.1.and.iendRGB.eq.1) goto 32
      write (36,3605) model(idup1),mDUP1,time(iDUP1),model(istartRGB),
     &     model(iendRGB),mHBS_DUP1,model(iHBS_DUP1)
 32   if (istartHe.eq.1.and.iendHe.eq.1) goto 33
      write (36,3611) model(istartHe),model(iendHe),dtHe,model(iHecore),
     &     mHecore,time(iendHe),tc(iendHe),xmHet(iendHe)
      write (36,3612) mHBS_He,iHBS_He,mHeBS_He,iHeBS_He
      write (36,3613) xspc(iendHe,ic12),xspc(iendHe,io16),
     &     xspc(iendHe,ine20),xspc(iendHe,ine22),xspc(iendHe,img24),
     &     xspc(iendHe,img25)
 33   if (idup2.eq.1) goto 34
      write (36,3615) model(idup2),mDUP2,time(iDUP2)
      write (36,3616) mHBS_DUP2,model(iHBS_DUP2),mHeBS_DUP2,
     &     model(iHeBS_DUP2),mCBS_DUP2,model(iCBS_DUP2)
 34   if (istartC.eq.iendC.and.iendC.eq.nmods) goto 35
      write (36,3621) model(istartC),model(iendC),dtC,mCcore_conv,
     &     model(iCcoremax),dtCcore_conv
      if (nflame.gt.0) then
         do i = 1,nflame
            k = -1
            do k = 1,nmodf
               if (modelf(k).eq.model(iCstart(i))) exit
            enddo
            if (k.lt.1.or.errflame.or.k.ge.nmodf) then
               write (36,3630) i,model(iCstart(i)),model(iCend(i)),
     &              time(iCend(i))-time(iCstart(i)),mCigni(i),mCmin(i),
     &              mCmax(i),time(iCstart(i)),lCmax(i),
     &              etamC(iCstart(i))
            else
               write (36,3631) i,model(iCstart(i)),model(iCend(i)),
     &              time(iCend(i))-time(iCstart(i)),mCigni(i),mCmin(i),
     &              mCmax(i),time(iCstart(i)),lCmax(i),
     &              etamC(iCstart(i)),xcflame(k)
            endif
         enddo
         write (36,'(1x)')
      endif
      write (36,3635) mNeOcore,model(iNeOcore),mCOcore,model(iCOcore)
     &     ,xspc(iendC,ine20),xspc(iendC,iO16),xspc(iendC,iNa23)
     &     ,xspc(iendC,iMg24)
      write (36,3636) iendC,mHBS_CB,iHBS_CB,mHeBS_CB,iHeBS_CB,mCBS_CB,
     &     iCBS_CB

 35   yo0 = xsps(istartH,iO15)/15.d0+xsps(istartH,iO16)/16.d0+
     &     xsps(istartH,iO17)/17.d0+xsps(istartH,iO18)/18.d0
      yc0 = xsps(istartH,ic12)/12.d0+xsps(istartH,ic13)/13.d0
      yo1 = xsps(iDUP1,iO15)/15.d0+xsps(iDUP1,iO16)/16.d0+
     &     xsps(iDUP1,iO17)/17.d0+xsps(iDUP1,iO18)/18.d0
      yc1 = xsps(iDUP1,ic12)/12.d0+xsps(iDUP1,ic13)/13.d0
      yo2 = xsps(iDUP2,iO15)/15.d0+xsps(iDUP2,iO16)/16.d0+
     &     xsps(iDUP2,iO17)/17.d0+xsps(iDUP2,iO18)/18.d0
      yc2 = xsps(iDUP2,ic12)/12.d0+xsps(iDUP2,ic13)/13.d0
      yo3 = xsps(nmods,iO15)/15.d0+xsps(nmods,iO16)/16.d0+
     &     xsps(nmods,iO17)/17.d0+xsps(nmods,iO18)/18.d0
      yc3 = xsps(nmods,ic12)/12.d0+xsps(nmods,ic13)/13.d0
      write (36,3641) xsps(istartH,ic12)/xsps(istartH,ic13)*13.d0/12.d0,
     &     xsps(iDUP1,ic12)/xsps(iDUP1,ic13)*13.d0/12.d0,
     &     xsps(iDUP2,ic12)/xsps(iDUP2,ic13)*13.d0/12.d0,
     &     xsps(nmods,ic12)/xsps(nmods,ic13)*13.d0/12.d0
      write (36,3643) log10(xsps(istartH,ili7)/xsps(istartH,ih1)/7),
     &     log10(xsps(iDUP1,ili7)/xsps(iDUP1,ih1)/7),
     &     log10(xsps(iDUP2,ili7)/xsps(iDUP2,ih1)/7),
     &     log10(xsps(nmods,ili7)/xsps(nmods,ih1)/7)
      write (36,3645) yc0/yo0,yc1/yo1,yc2/yo2,yc3/yo3
      write (36,3647)
      do i =1,nspi
         write (36,3648) chemi(i),xsps(1,i),xsps(iDUP1,i),xsps(iDUP2,i),
     &        xsps(nmods,i),xspc(iendH,i),xspc(iendHe,i),
     &        xspc(iendC,i),xspc(nmods,i)
      enddo

      !Create file '.sm'
      open (unit = 37, file = seqname(1:lenc(seqname)) // '.sm',
     &     action = 'write' , status = 'unknown')

      write(37,3650) mtot(1),zini,Yini,mDUP1,mDUP2,mHcore,
     &     mHecore,mCcore_conv,mNeOcore,mtot(iendC),leff(istartC),nflame
     &     ,(mCigni(kk),mCmin(kk),mCmax(kk),lCmax(kk),leff(iCstart(kk)),
     &     etamC(iCstart(kk)-1),time(iCend(kk))-time(iCstart(kk)), 
     &     kk= 1,min(nflame,10))


c      !Create file '.xspc'
c      open (unit = 38, file = seqname(1:lenc(seqname)) // '.xspc',
c     &     action = 'write' , status = 'unknown')
 
c      write(38,3660) mtot(1),zini,Yini,xspc(iendH,ihe4),
c     &     xspc(iendH,ic12),xspc(iendH,in14),xspc(iendH,io16),
c     &     xspc(iendHe,ic12),xspc(iendHe,io16),xspc(iendHe,ine20),
c     &     xspc(iendHe,ine22),xspc(iendHe,img24),xspc(iendHe,img25),
c     &     xspc(iendC,iO16),xspc(iendC,ine20),xspc(iendC,iNa23),
c     &     xspc(iendC,iMg24)      


      !Create file '.dat'
      open (unit = 39, file = seqname(1:lenc(seqname)) // '.dat',
     &     action = 'write' , status = 'unknown')

      write(39,3670) mtot(1),zini,Yini,mDUP1,mDUP2,
     &     mHcore,xmHm(iendH),xmHt(iendH),mtot(iendH),mHBS_Ms,
     &     mHecore,xmHem(iendHe),xmHet(iendHe),mHeBS_He,mHBS_He,
     &     mtot(iendHe),
     &     mNeOcore,mCBS_CB,xmCm(iendC),xmCt(iendC),mHeBS_CB,
     &     xmHem(iendC),xmHet(iendC),mHBS_CB,xmHm(iendC),xmHt(iendC),
     &     mtot(iendC),mCOcore,
     &     dtH,dtHe,dtC

c       !Create file '.tab1'
c       open (unit = 48, file = seqname(1:lenc(seqname)) // '.tab1',
c      &     action = 'write' , status = 'unknown')

c       xmHeC = sqrt(xmHem(iCstart(1))*xmHet(iCstart(1)))
c       write(48,4800) mtot(1),mHcore,mhecore,mdup1,xmHeC,dth
c      &     *1.d-7,dthe*1.d-6,(time(iCstart(1))-time(iendHe))*1.d-5,
c      &     xspc(istartC,ic12),xspc(istartC,io16)
c c     &     xspc(iendHe,ic12),xspc(iendHe,io16)
c  4800 format (0pf4.1,4(' &  ',0pf5.3),' &  ',0pf4.2,'\,$10^7$ & ',0pf4.2
c      &     ,'\,$10^6$ & ',0pf4.2,'\,$10^5$',2(' & ',0pf5.3),' \\ ')

c       !Create file '.tab2'
c       open (unit = 49, file = seqname(1:lenc(seqname)) // '.tab2',
c      &     action = 'write' , status = 'unknown')
 
c       k  = idup1
c       write(49,4900) mtot(1),xsps(k,ih1),xsps(k,ihe3)*1.d5,xsps(k,ihe4),
c      &     xsps(k,ic12)*1.d3,xsps(k,ic13)*1.d4,xsps(k,in14)*1.d3,
c      &     xsps(k,in15)*1.d6,xsps(k,io16)*1.d3,xsps(k,io17)*1.d5,
c      &     xsps(k,io18)*1.d5,xsps(k,ine21)*1.d6,xsps(k,ine22)*1.d4,
c      &     xsps(k,ina23)*1.d5,xsps(k,img25)*1.d5,xsps(k,img26)*1.d5
c  4900 format (0pf4.1,' & ',0pf5.3,' & ',0pf4.2,' & ',0pf5.3,
c      &     12(' & ',0pf4.2),' \\')

c       !Create file '.tab3'
c       open (unit = 50, file = seqname(1:lenc(seqname)) // '.tab3',
c      &     action = 'write' , status = 'unknown')
 
c       if (mCigni(1).eq.0.d0.or.mCmin(1).eq.0.d0) then
c          xcf1 = xspc(ilCmax(1),ic12)
c          xcf2 = 0.d0
c       else
c          xcf1 = 9.999d0
c          xcf2 = 9.999d0
c          do k = 1,nmodf
c             if (modelf(k).eq.model(ilCmax(1))) then
c                xcf1 = xcflame(k)
c                exit
c             endif
c          enddo
c          do j = k+1,nmodf
c             if (modelf(j).eq.model(ilCmax(2))) then
c                xcf2 = xcflame(j)
c                exit
c             endif
c          enddo
c       endif

c       write(50,5000) mtot(1),time(iCstart(1))*1.d-7,
c      &     int(xrb(iCstart(1))*reff(iCstart(1))*6.9599d5),mCigni(1),
c      &     int(time(iCend(1)-1)-time(iCstart(1))),
c      &     lCmax(1)/10d0**int(log10(lCmax(1))),
c      &     int(log10(lCmax(1))),mCmax(1)-mCmin(1),xcf1,
c      &     int(xrb(iCstart(2))*reff(iCstart(2))*6.9599d5),mCigni(2),
c      &     int(time(iCend(2))-time(iCstart(2))),
c      &     lCmax(2)/10d0**int(log10(lCmax(2))),int(log10(lCmax(2))),xcf2

c  5000 format (0pf4.1,' & ',0pf8.6,' & ',i4,' & ',0pf5.3,' & ',i4,' & ',
c      &     0pf3.1,'\,$10^',i1,'$ & ',0pf5.3,' & ',0pf5.3,' & ',i4,
c      &     ' & ',0pf5.3,
c      &     ' & ',i5,' & ',0pf3.1,'\,$10^',i1,'$ & ',0pf5.3,' \\')

c       !Create file '.tab4'
c       open (unit = 51, file = seqname(1:lenc(seqname)) // '.tab4',
c      &     action = 'write' , status = 'unknown')

c       write (51,5100) mtot(1),mtot(iendC),mNeOcore,mCOcore,mDUP2
c  5100 format(0pf4.1,' & ',0pf5.2,3(' & ',0pf5.3),' \\')


c       !Create file '.tab5'
c       open (unit = 52, file = seqname(1:lenc(seqname)) // '.tab5',
c      &     action = 'write' , status = 'unknown')

c       k  = idup2
c       write(52,5200) mtot(1),xsps(k,ih1),xsps(k,ihe3)*1.d5,xsps(k,ihe4),
c      &     xsps(k,ic12)*1.d3,xsps(k,ic13)*1.d5,xsps(k,in14)*1.d3,
c      &     xsps(k,in15)*1.d6,xsps(k,io16)*1.d3,xsps(k,io17)*1.d5,
c      &     xsps(k,io18)*1.d5,xsps(k,ine21)*1.d6,xsps(k,ine22)*1.d4,
c      &     xsps(k,ina23)*1.d5,xsps(k,img25)*1.d5,xsps(k,img26)*1.d5
c  5200 format (0pf4.1,' & ',0pf5.3,' & ',0pf4.2,' & ',0pf5.3,' & ',0pf4.2
c      &     ,' & ',0pf5.2,10(' & ',0pf4.2),' \\')



      !close input and output data files
      close (10)
      close (11)
      close (12)
      close (13)
      close (14)
      close (15)
      close (16)
      close (17)
      close (21)
      close (22)
      close (23)
      close (24)
      close (25)
      close (30)
      close (31)
      close (32)
      close (33)
      close (35)
      close (36)
      close (37)
      close (38)
      close (39)
c      close (48)
c      close (49)
c      close (50)
c      close (51)
c      close (52)
      close (61)

      !formats used in reading or writing operations
 990  format (6(1x,/))

 1003 format (i7,127x,i5)

 3000 format (2x,1pe15.9,3x,1pe7.1,/,
     &     '#Total integrated CPU time used : ',0pf8.1,' h')
 3100 format (' npul',2x,'mpulse seqpulse',2x,'mtop seqtop',
     &     2x,'mend seqend',3x,'mdup seqdup',5x,'tp_start',
     &     6x,'dtpulse',3x,'dtinter',4x,'eta_He',3x,'rHeBS',4x,'Tenv')
 3101 format (1x,i3,3x,4(i7,' ',i4,' ',1x),1pe15.9,1x,0pf9.4,1x,1pe11.5,
     &     1x,0pf7.3,1x,1pe9.3,1x,1pe9.3)

 3200 format (' npul',6x,'Mtp',10x,'Ltp',11x,'Rtp',11x,'Mlosstp',9x,
     &     'pulse_Tb',3x,'pulse_Tt',3x,'pulse_rob',4x,'pulse_rot',2x,
     &     'pulse_mHeBS',1x,'pulse_rHeBS')
 3201 format (1x,i3,2x,0pf11.8,4x,0pf9.2,6x,0pf7.2,8x,1pe10.4,
     &     6x,1pe10.4,1x,1pe10.4,2x,1pe10.4,3x,1pe10.4,2x,0pf9.7,3x,
     &     1pe9.3)

 3300 format (' npul',1x,'pulse_Mcore',1x,'pulse_Mbm',1x,
     &     'pulse_LHem',1x,'pulse_dmmax',1x,'fdilu',2x,
     &     'fovlap',1x,'dupH',2x,'dup_dm',3x,'lambda',3x,
     &     'dmHpul',3x,'dup_Tb',4x,'dMcore',5x,'dMcore_eff')
 3301 format (1x,i3,2x,0pf10.7,1x,0pf10.7,1x,1pe10.4,2x,0pf9.7,2x,
     &     0pf6.4,1x,0pf6.4,3x,i1,2x,0pf8.6,1x,0pf7.4,1x,0pf8.6,2(1x,
     &     1pe10.4),1x,1pe11.4)

 3501 format (1x,i3,1x,5(1x,i4),1x,5(1x,0pf12.10))

 3600 format ('General information',/,'initial mass = ',0pf9.6,
     &     ', Z = ',1pe10.4,', filename = ',A,/)
 3601 format ('o  H main sequence : [',i5,',',i5,'], duration : ',
     &     1pe10.4,', max core extend [',i5,'] ',0pf11.8,' Mo')
 3602 format (' - End H main sequence, m_HBS = ',0pf8.5,' Mo [',i5,']')
 3603 format ('   Central mass fractions: He4 = ',1pe10.4,
     &     ', C12 = ',1pe10.4,', N14 = ',1pe10.4,', O16 = ',1pe10.4)
 3605 format (/,'o  1DUP : MDUP1 [',i5,'] = ',0pf11.8,' Mo, ',
     &     'time = ',1pe10.4,', RGB phase : [',i4,',',i5,'], m_HBSm =',
     &     0pf8.5,' Mo [',i5,']')
 3611 format (/,'o  He main sequence : [',i5,',',i5,'], duration : ',
     &     1pe10.4,', max core extend [',i5,'] ',0pf11.8,' Mo',/
     &     '   tHe_end = ',1pe10.4,' Tc_endHe = ',1pe10.4,
     &     ', m_HeBS_top_endHe = ',0pf11.8)
 3612 format (' - End He main sequence, m_HBSm = ',0pf8.5,' Mo [',i5,
     &     '], m_HeBSm = ',0pf8.5,' Mo [',i5,']')
 3613 format ('   Central mass fractions: C12 = ',1pe10.4,
     &     ', O16 = ',1pe10.4,', Ne20 = ',1pe10.4,', Ne22 = ',1pe10.4,
     &     ', Mg24 = ',1pe10.4,', Mg25 = ',1pe10.4)
 3615 format (/,'o  2DUP : MDUP2 [',i5,'] = ',0pf11.8,' Mo, time = ',
     &     1pe10.4)
 3616 format ('   m_HBS =',0pf8.5,' Mo [',i5,'],',' m_HeBS = ',0pf8.5,
     &     ' Mo [',i5,'], m_CBS = ',0pf8.5,' Mo [',i5,']')
 3621 format (/,'o  C main sequence : [',i6,',',i6,'], duration : ',
     &     1pe10.4,', conv. core : ',0pf11.8,' Mo [',i6,'], ',
     &     'conv core duration : ',1pe10.4,' (yr)')
 3630 format (' CZ',i2,' [',i5,',',i5,'], dt = ',1pe9.3,
     &     ', Migni= ',0pf7.4,' Mmin= ',0pf7.4,' Mmax= ',
     &     0pf7.4,' , tstart: ',1pe12.6, ', lCmax= ',1pe9.3, 
     &     ', Cburn_etam:',0pf7.3)
 3631 format (' CZ',i2,' [',i5,',',i5,'], dt = ',1pe9.3,
     &     ', Migni= ',0pf7.4,' Mmin= ',0pf7.4,' Mmax= ',
     &     0pf7.4,' , tstart: ',1pe12.6, ', lCmax= ',1pe9.3, 
     &     ', Cburn_etam:',0pf7.3,', XC12_flame:',0pf10.7)
 3635 format (' - NeO core mass : ',0pf8.5,' Mo [',i6,'],',
     &     ' CO core mass : ',0pf8.5,' Mo [',i6,']',/,
     &     '   Central mass fractions Ne20 = ',1pe10.4,', O16 = ',
     &     1pe10.4,', Na23 = ',1pe10.4,', Mg24 = ',1pe10.4)
 3636 format (' - End core C burning [',i5,'], m_HBSm =',0pf8.5,
     &     ' Mo [',i5,'], m_HeBSm = ',0pf8.5,' Mo [',i5,'], m_CBSm = ',
     &     0pf8.5,' Mo [',i5,']')
 3641 format (/,'o  Chemical features :',/,14x,'MS',7x,'DUP1',6x,'DUP2',
     &     7x,'END ',/,1x,'C12/C13',4(2x,0pf8.3))
 3643 format (1x,' N(Li) ',4(2x,0pf8.3))
 3645 format (1x,' [C/O] ',4(2x,0pf8.3))
 3647 format (/,'Abundances:',12x,'Surface',16x,'||',16x,'Center',/,
     &     '         Init      1DUP       2DUP       end',
     &     '      end H     end He     end C       end')
 3648 format (1x,a5,2x,8(1pe8.2,2x))
      !IMPORTANT: this format is right if nflame <= 50 (see below 
      !the value equal to 10: "&     10(3(1X,F7.4),..etc.......").
      !This value is equal to ncarbon 
 3650 format (1x,f6.3,2(1x,es9.3),7(1x,f8.5),1x,es10.4,1x,i2
     &     ,10(3(1x,f7.4),2(1x,es10.4),1x,f7.3,1x,es9.3))
 3660 format (1x,f6.3,2(1x,es9.3),2x,4(1x,1pe10.4),2x,6(1x,1pe10.4),2x,4
     &     (1x,1pe10.4))
 3670 format (1x,f6.3,2(1x,es9.3),2(1x,f8.5),1x,5(1x,f8.5),1x,6(1x,f8.5)
     &     ,1x,12(1x,f8.5),3(1x,es10.4))
 4000 format (1x,'Mass lost in the wind = ',0pf8.5,', Mass remaining ',
     &     'in conv. env. = ',0pf8.5,', initial Mass = ',0pf8.5,
     &     ', Zini = ',0pf8.6)
 4010 format (10x,' Ejected  -- Yields',24x,' Ejected  -- Yields',/,
     &        10x,'     (in winds)    ',24x,' (with conv. env.) ')
 4020 format (1x,a5,3x,1pe11.4,2x,1pe11.4,20x,1pe11.4,2x,1pe11.4)

      end


************************************************************************

      INTEGER FUNCTION LENC (a)

************************************************************************
* Give last non-blank character position in string a                   *
************************************************************************

      implicit none

      character*(*) a

      integer i,n

      n = len(a)
      do 10 i = n,1,-1
         if (a(i:i).ne.' ') then
            lenc = i
            return
         end if
 10   continue

      lenc = 0

      return
      end
